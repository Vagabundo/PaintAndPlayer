/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package prFinal;

import java.awt.*;
import java.awt.geom.*;
import java.awt.image.*;
import java.io.File;
import java.io.*;
import java.util.ArrayList;
import javax.imageio.*;

/**
 * Clase que hereda de JPanel y contiene funciones para agregar formas y colores a una imagen dada
 * 
 * @author Roberto
 */
public class LienzoImagen extends javax.swing.JPanel {

    /**
     * Creates new form LienzoImagen
     * @param parent puntero al frame principal
     * @param img imagen del lienzo
     * @param figura tipo de figura a dibujar o modificar: 1 punto, 2 línea, 3 rectángulo, 4 elipse, 5 rectángulo ovalado
     * @param nombreImg nombre de la imagen
     */
    
    JFramePrFinal parent;
    BufferedImage img;
    int figura;  
    String nombreImg;
    
    public LienzoImagen(JFramePrFinal parent){
        this.parent = parent;
        this.figura = 1;
        this.setBackground(Color.GRAY);
        img = null;
        initComponents();
    }
    public LienzoImagen() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    /**
     * Acciones al presionar el boton del ratón:
     * 1º actualizamos punto pos1 (se usa en la función create)
     * 2º si editar está seleccionado: obtenemos la clase del último shape
     * 3º si no: guardamos el shape actual en img, y creamos uno nuevo en el punto presionado
     * @param evt 
     */
    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
        pos1 = evt.getPoint();
        if (editar()){
            //s = getSelectedShape(pos1);
            if (s != null){
                figura = clase(s);
                p1 = new Point2D.Double();
                p2 = new Point2D.Double();
            }
        }
        else{
            if (img != null)
                this.imgPaint();
            figura = figura();
            createShape();
        }
    }//GEN-LAST:event_formMousePressed

    /**
     * Acciones al mover el ratón con el botón presionado:
     * 1º actualizo pos2 (se usa en las funciones edit y update)
     * 2º si editar: edito el shape y actualizo pos1
     * 3º si no editar: actualizo el shape actual
     * @param evt 
     */
    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        pos2 = evt.getPoint();
        
        if (editar()){
            if(s != null){                
                editShape();
                pos1 = pos2;
            }
        }
        else
            updateShape();
        
        this.repaint();
    }//GEN-LAST:event_formMouseDragged
    
    /**
     * Acciones al levantar el boton del ratón:
     * 1º actualizo pos2 (se usa en las funciones edit y update)
     * 2º si editar: edito el shape y actualizo pos1
     * 3º si no editar: actualizo el shape actual 
     * @param evt 
     */
    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
        pos2 = evt.getPoint();
        
        if (editar()){
            if(s != null){                
                editShape();
                pos1 = pos2;
            }
        }
        else            
            updateShape();
        
        this.repaint();
    }//GEN-LAST:event_formMouseReleased


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    
    //Declaración de variables de formas
    Point2D p1, p2;
    Point2D p3, p4, pos1, pos2;
    Point2D p = new Point2D.Double();
    Line2D l = new Line2D.Double();
    Rectangle2D r = new Rectangle2D.Double();
    RoundRectangle2D rr = new RoundRectangle2D.Double();
    Ellipse2D e = new Ellipse2D.Double();
    Shape s = null;
    
    //vShape no usado al final
    ArrayList<Shape> vShape = new ArrayList();
    
    // vector de stroke punteado    
    float dash1[] = {10.0f};
    
    /**
     * Funcion que crea un nuevo Shape, dependiendo
     * de la figura seleccionada por el usuario
     */
    private void createShape (){
        switch (figura()){
            case 1:
                l = new Line2D.Double(pos1,pos1);
                vShape.add(l);
                s = l;
                break;
            case 2:
                l = new Line2D.Double(pos1,pos1);
                vShape.add(l);
                s = l;
                break;
            case 3:
                r = new Rectangle2D.Double();
                r.setFrameFromDiagonal(pos1, pos1);
                vShape.add(r);
                s = r;
                break;
            case 4:
                e = new Ellipse2D.Double();
                e.setFrameFromDiagonal(pos1, pos1);
                vShape.add(e);
                s = e;
                break;
            case 5:
                rr = new RoundRectangle2D.Double(pos1.getX(), pos1.getY(), 0, 0, 10, 10);
                rr.setFrameFromDiagonal(pos1, pos1);
                vShape.add(rr);
                s = rr;
                break;
            default:
                break;
        }
    }
    
    /**
     * Función que actualiza el shape actual con el evento dragged
     */
    private void updateShape (){
        switch (figura()){
            case 1:
                l.setLine(pos2, pos2);
                break;
            case 2:
                l.setLine(l.getP1(), pos2);
                break;
            case 3:
                r.setFrameFromDiagonal(pos1, pos2);
                break;
            case 4:
                e.setFrameFromDiagonal(pos1, pos2);
                break;
            case 5:
                rr.setFrameFromDiagonal(pos1, pos2);
                break;
            default:
                break;
        }
    }
    
    /**
     * Función que edita el último shape debujado
     */
    private void editShape (){
        double dx = (pos1.getX()-pos2.getX());
        double dy = (pos1.getY()-pos2.getY());
        
        switch (figura){
            case 1:
                //l.setLine((l.getX1()-dx), (l.getY1()-dy), (l.getX1()-dx), (l.getY1()-dy));
                l.setLine(pos2, pos2);
                break;
            case 2:
                l.setLine((l.getX1()-dx), (l.getY1()-dy), (l.getX2()-dx), (l.getY2()-dy));
                break;
            case 3:
                p1.setLocation(r.getCenterX() - dx, r.getCenterY() - dy);
                p2.setLocation(p1.getX() + (r.getWidth()/2), p1.getY() + (r.getHeight()/2));
                r.setFrameFromCenter(p1, p2);
                break;
            case 4:
                p1.setLocation(e.getCenterX() - dx, e.getCenterY() - dy);
                p2.setLocation(p1.getX() + (e.getWidth()/2), p1.getY() + (e.getHeight()/2));
                e.setFrameFromCenter(p1, p2);
                break;
            case 5:
                p1.setLocation(rr.getCenterX() - dx, rr.getCenterY() - dy);
                p2.setLocation(p1.getX() + (rr.getWidth()/2), p1.getY() + (rr.getHeight()/2));
                rr.setFrameFromCenter(p1, p2);
                break;
            default:
                break;
        }
    }

    /**
     * Función que pinta en el lienzo según los datos obtenidos de parent
     * @param g 
     */
    @Override
    public void paint(Graphics g){
        super.paint(g);
        Graphics2D g2d = (Graphics2D)g;

        // Código para pintar Shapes
        //Iniciar el stroke y setStroke
        g2d.setPaint(colorLinea());
        
        if (punteada())
            g2d.setStroke (new BasicStroke (grosor(), BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash1, 0.0f));
        else
            g2d.setStroke(new BasicStroke (grosor()));
        
        //cargo imagen
        if(img != null){
            g2d.drawImage(img,0,0,this);
            if (s != null){
                if(relleno() && (figura > 2)){
                    switch (typeRelleno()){
                        case 0:
                            g2d.setPaint(colorRelleno());
                            g2d.fill(s);
                            g2d.setPaint(colorLinea());
                            break;
                        case 1:
                            g2d.setPaint(new GradientPaint((float)((RectangularShape)s).getMinX(), (float)((RectangularShape)s).getCenterY(), colorLinea(), (float)((RectangularShape)s).getMaxX(), (float)((RectangularShape)s).getCenterY(), colorRelleno()));
                            g2d.fill(s);
                            g2d.setPaint(colorLinea());
                            break;
                        case 2:
                            g2d.setPaint(new GradientPaint((float)((RectangularShape)s).getCenterX(), (float)((RectangularShape)s).getMinY(), colorLinea(), (float)((RectangularShape)s).getCenterX(), (float)((RectangularShape)s).getMaxY(), colorRelleno()));
                            g2d.fill(s);
                            g2d.setPaint(colorLinea());
                            break;
                        default:
                            break;
                    }
                }
                g2d.draw(s);
            }
        }
        
        //Código para pintar vectores de shapes (NO REQUERIDO ni usado)
        else{
        //Shape
            for(Shape sl:vShape){
                if(relleno() && (figura > 2)){
                    switch (typeRelleno()){
                        case 0:
                            g2d.setPaint(colorRelleno());
                            g2d.fill(s);
                            g2d.setPaint(colorLinea());
                            break;
                        case 1:
                            g2d.setPaint(new GradientPaint((float)((RectangularShape)s).getMinX(), (float)((RectangularShape)s).getCenterY(), colorLinea(), (float)((RectangularShape)s).getMaxX(), (float)((RectangularShape)s).getCenterY(), colorRelleno()));
                            g2d.fill(s);
                            g2d.setPaint(colorLinea());
                            break;
                        case 2:
                            g2d.setPaint(new GradientPaint((float)((RectangularShape)s).getCenterX(), (float)((RectangularShape)s).getMinY(), colorLinea(), (float)((RectangularShape)s).getCenterX(), (float)((RectangularShape)s).getMaxY(), colorRelleno()));
                            g2d.fill(s);
                            g2d.setPaint(colorLinea());
                            break;
                        default:
                            break;
                    }
                }
                g2d.draw(sl);
            }
        }
    }
    
    /**
     * Función que pinta el shape actual sobre la imagen img definitivamente
     */
    public void imgPaint(){
        Graphics2D gImg = (Graphics2D) img.getGraphics();

        // Código para pintar Shapes
        //Inicial el stroke y setStroke
        gImg.setPaint(colorLinea());
        
        if (punteada())
            gImg.setStroke (new BasicStroke (grosor(), BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash1, 0.0f));
        else
            gImg.setStroke(new BasicStroke (grosor()));
        
        //Grabo el shape actual
        if (s != null){
            if(relleno() && (figura > 2)){
                switch (typeRelleno()){
                    case 0:
                        gImg.setPaint(colorRelleno());
                        gImg.fill(s);
                        gImg.setPaint(colorLinea());
                        break;
                    case 1:
                        gImg.setPaint(new GradientPaint((float)((RectangularShape)s).getMinX(), (float)((RectangularShape)s).getCenterY(), colorLinea(), (float)((RectangularShape)s).getMaxX(), (float)((RectangularShape)s).getCenterY(), colorRelleno()));
                        gImg.fill(s);
                        gImg.setPaint(colorLinea());
                        break;
                    case 2:
                        gImg.setPaint(new GradientPaint((float)((RectangularShape)s).getCenterX(), (float)((RectangularShape)s).getMinY(), colorLinea(), (float)((RectangularShape)s).getCenterX(), (float)((RectangularShape)s).getMaxY(), colorRelleno()));
                        gImg.fill(s);
                        gImg.setPaint(colorLinea());
                        break;
                    default:
                        break;
                }
            }
            gImg.draw(s);
        }
    }
    
    //Edición de los shapes
    
    /**
     * Función que devuelve la línea line está cerca de un punto dado p
     * @param line
     * @param p
     * @return 
     */
    private boolean isNear(Line2D line, Point2D p){
        return line.ptLineDist(p) <= 2.0;
    }
    
    /**
     * Función que selecciona un shape cercano (NO REQUERIDO)
     */
    private Shape getSelectedShape(Point2D p){
        for(Shape sv:vShape){
            if (sv.getClass() == l.getClass()){
                if (l.getP1().distance(p) <= 2.0){
                    //vShape.remove(sv);
                    return sv;
                }
                if(isNear((Line2D)sv,p)){
                    //vShape.remove(sv);
                    return sv;
                }
            }
            else
                if (sv.contains(p)){
                    //vShape.remove(sv);
                    return sv;
                }
        }
        
        return null;
    }
    
    //Funciones de formas
    
    /**
     * Función que pregunta al frame principal si Editar está seleccionado
     * @return 
     */
    private boolean editar(){
        return parent.editar();
    }

    /**
     * Función que pregunta al frame principal si Relleno está seleccionado
     * @return 
     */
    private boolean relleno(){
        return parent.relleno();
    }
    
    /**
     * Función que pregunta al frame principal el tipo de relleno seleccionado
     * @return 
     */    
    private int typeRelleno(){
        return parent.tipoRelleno();
    }

    /**
     * Función que pregunta al frame principal el color de relleno seleccionado
     * @return 
     */
    private Color colorRelleno(){
        return parent.colorRelleno();
    }
    
    /**
     * Función que pregunta al frame principal el color de línea seleccionado
     * @return 
     */
    private Color colorLinea(){
        return parent.colorLinea();
    }
    
    /**
     * Función que pregunta al frame principal el grosor seleccionado
     * @return 
     */    
    private float grosor(){
        return parent.grosor();
    }
    
    /**
     * Función que pregunta al frame principal el tipo de línea seleccionada
     * @return 
     */
    private boolean punteada(){
        return parent.lineaPunteada();
    }

    /**
     * Función que pregunta al frame principal el tipo de figura seleccionada
     * @return 
     */    
    private int figura(){
        return parent.figura();
    }

    /**
     * Función que actuaaliza el texto de la barra de estado del frame principal
     */    
    private void setTexto (String st){
        parent.setBarraEstado(st);
    }
    
    /**
     * Función que devuelve la clase de figura dado un shape sl
     * @param sl
     * @return tipo del shape
     */
    private int clase(Shape sl){
        if (sl != null){
            if (sl.getClass() == l.getClass()){
                l = (Line2D.Double) sl;
                if (l.getP1().equals(l.getP2())){
                    setTexto("Clase 1");
                    return 1;
                }
                setTexto("Clase 2");
                return 2;
            }
            if (sl.getClass() == r.getClass()){
                r = (Rectangle2D.Double) sl;
                setTexto("Clase 3");
                return 3;
            }
            if (sl.getClass() == e.getClass()){
                e = (Ellipse2D.Double) sl;
                setTexto("Clase 4");
                return 4;
            }
            if (sl.getClass() == rr.getClass()){
                rr = (RoundRectangle2D.Double) sl;
                setTexto("Clase 5");
                return 5;
            }
        }
        setTexto("Clase 0");
        return 0;
    }
    
    //Funciones de imagen cargada
    
    /**
     * Función que asigna la imagen i a la imagen img de la clase, y ajusta el tamaño del lienzo a su tamaño
     * @param i 
     */
    void setImage(BufferedImage i) {
        img = i;
        setPreferredSize(new Dimension(img.getWidth(),img.getHeight()));
    }
    
    /**
     * Función que almacena el nombre de la imagen
     * @return 
     */
    void setNombreImg (String n){
        nombreImg = n;
    }

    /**
     * Función que devuelve el nombre de la imagen
     * @return 
     */    
    String getNombreImg(){
        return nombreImg;
    }
    
    /**
     * Función que devuelve la imagen
     * @return 
     */    
    BufferedImage getImage(){
        return img;
    }
}
